---
title: "Bayesian Latent Severity LCA"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.path = "README_files/"
)
```


A **Bayesian latent class model with continuous severity** for diagnostic test evaluation.

This project extends classical Hui–Walter and random-effects LCA frameworks by introducing a continuous *latent severity* parameter \(S_i\).  
The approach enables efficient estimation of diagnostic accuracies and prevalence using **fewer than four assays**, addressing common identifiability limitations in small-panel diagnostic evaluations.


---

## Overview

Traditional latent class models assume conditional independence between binary tests given a latent disease status.  
The **Latent Severity LCA (S-LCA)** relaxes this by allowing within-class variability in disease expression:

\[
T_{ij}^* = \beta_j S_i + \gamma_j + \varepsilon_{ij}, 
\qquad T_{ij} = \mathbb{I}(T_{ij}^* > 0)
\]

Here, \(S_i\) captures the strength or intensity of infection for diseased subjects (\(D_i = 1\)), producing more realistic inference on test sensitivity, specificity, and prevalence.

---

### 1. `bayesian_severity_LCA()`

A unified function implementing two prior choices for the latent severity parameter \( S_i \):

- **Gamma Severity Model**  
  $S_i \mid D_i = 1 \sim \mathrm{Gamma}(\alpha_S, \beta_S)$, 
  $\beta_S \sim \mathrm{Gamma}(a_\beta, b_\beta)$

- **Normal Moment (NM⁺) Severity Model**  
  $p(S_i \mid D_i = 1) \propto S_i^2 \exp[-(S_i - \mu_0)^2 / (2\tau^2)]$, 
  $S_i > 0$, 
  $\tau^2 \sim \mathrm{Inv\text{-}Gamma}(a_\tau, b_\tau)$

Both models employ MCMC with truncated-normal data augmentation for latent test variables, and include posterior updates for:

- Class indicator \( D_i \)

- Test parameters \( (\beta_j, \gamma_j, \sigma_j^2) \)

- Prevalence \( \rho \)

- Severity priors (Gamma or NM+)

---

### Candidate Priors for Severity

The following figure compares the Gamma and NM+ priors for \( S_i \) when each has variance = 1:

```{r, echo = FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
sample_NM <- function(n, mu0, tau, grid_size = 1e4) {
  x_vals <- seq(0, mu0 + 6 * tau, length.out = grid_size)
  dens_vals <- 2 * (x_vals^2) / (sqrt(2 * pi) * tau^3) * 
    exp(-((x_vals - mu0)^2) / (2 * tau^2))
  dx <- x_vals[2] - x_vals[1]
  dens_vals <- dens_vals / sum(dens_vals * dx)
  
  cdf_vals <- cumsum(dens_vals * dx)
  
  # Sample from uniform and interpolate inverse CDF
  u <- runif(n)
  samples <- approx(cdf_vals, x_vals, xout = u, rule = 2)$y
  
  return(samples)
}
N = 5000
vart = 1/sqrt(3 - 8/pi)
Si_nm  <- sample_NM(N, mu0 = 0, tau = vart)          
Si_gam <- rgamma(N, shape = 4.5, rate = sqrt(4.5))                

df <- tibble(
  NMplus = Si_nm,
  Gamma  = Si_gam
) %>%
  pivot_longer(cols = everything(),
               names_to = "Distribution",
               values_to = "S") %>%
  mutate(
    Distribution = factor(
      Distribution,
      levels = c("NMplus", "Gamma"),
      labels = c(
        "NM⁺ (μ = 0, τ = 1/√(3 − 8/π))",
        "Gamma (shape = 4.5, rate = √4.5)"
      )
    )
  )

ggplot(df, aes(x = S, fill = Distribution, color = Distribution)) +
  geom_density(alpha = 0.3, adjust = 1.2) +
  scale_x_continuous(limits = c(0, 8)) +
  labs(
    title = "Candidate priors for latent severity S",
    x = expression(S[i]),
    y = "Density"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.title = element_blank())
```





```{r, echo = FALSE}
# rmarkdown::render(
#     "README.Rmd",
#     output_format = "rmarkdown::github_document",
#     output_file = "README.md"
# )
```

